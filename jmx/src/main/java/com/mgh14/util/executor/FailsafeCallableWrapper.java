package com.mgh14.util.executor;

// I already spent 81 minutes and 11 seconds writing a class that will do this in a previous session. When I
// went to upload my answer, however, my internet connection went bad and I was unable to submit my work :(
// Here is the class that I created. I hope that it's good enough. If not, please let me know and I will re-take
// the test with a different question.

import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Callable;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Callable;


/**
 * This class is a wrapper class intended to generically handle exceptions thrown by
 * executable objects. This class will store failed executable objects (i.e. any
 * executable object that throws an exception) and prevent the failed object's
 * re-execution. If the executable runs to completion without throwing an exception,
 * then the original return value of the executable is returned. In the way of example,
 * assume we have a Callable object that always throws an exception as in the following
 * code block:
 *
 * <code>
 * new Callable exceptionCallable = () -> {
 *      if (true) {
 *          throw new IllegalStateException("This state is always illegal");
 *      }
 * }
 * </code>
 *
 * This is a legal Callable and will be accepted by our object instance: a non-null
 * wrapper for such a Callable will be returned. However, if we then attempt to execute
 * the wrapper generated for the <code>exceptionCallable</code> Callable, then an
 * exception will inevitably be thrown (by the original callable) and this class will
 * store the <code>exceptionCallable</code> object in order to prevent its re-execution.
 * Of course <code>exceptionCallable</code> could still be executed outside of a
 * wrapper function, but when wrapped by this class in a Callable object then the
 * Callable will not be able to run again. We refer to this as a "failsafe Callable",
 * which functionality this wrapper class intends to provide in order to prevent
 * error conditions that must not or should not be duplicated.
 *
 * For completeness we also provide an example of a successful executable:
 *
 * <code>
 * new Callable successfulCallable = () -> {
 *      return new Boolean(true);
 * }
 * </code>
 *
 * In this case the failsafe wrapper function generated will simply return the
 * <code>Boolean(true)</code> result generated by the original executable because
 * the original executable itself will not throw an exception.
 */
public class FailsafeCallableWrapper {

    private static final Logger logger = LoggerFactory
            .getLogger(FailsafeCallableWrapper.class);

    private Set<Callable> failedCallables;

    public FailsafeCallableWrapper() {
        this.failedCallables = new TreeSet<>();
    }

    /**
     * Method for creating a "failsafe" Callable wrapper around another
     * Callable object. The Callable object returned by this method
     * will return the original Callable value without any modification
     * unless the original Callable parameter throws an exception, in which
     * case the returned Callable will prevent the Callable parameter's
     * re-execution. See the class notes above for an example.
     *
     * @param execute the Callable that will be wrapped in a failsafe
     *                Callable object.
     * @return a Callable that returns the original value of the
     * targeted Callable parameter. This method will also return null in the
     * event of 1) a null parameter, 2) a Callable parameter that throws an
     * exception, or 3) a failsafe-wrapped Callable parameter that has been
     * previously attempted and threw an exception.
     */
    public Callable getWrapperForCallable(Callable execute) {
        if (execute == null) {
            logger.warn("Unable to wrap null callable parameter.");
            return null;
        }

        return () -> {
            String executeName = getCallableName(execute);
            if (failedCallables.contains(execute)) {
                logger.error("Exception thrown during execution of callable {}; " +
                        "unable to re-execute.", executeName);
                return null;
            }

            try {
                return execute.call();
            } catch (Exception e) {
                logger.error("Unable to complete execution for callable {}. " +
                        "Exception thrown:", executeName, e);
                failedCallables.add(execute);   // never should add duplicate callables
                // (even if data structure used isn't a set)
            }

            return null;
        };
    }

    private static String getCallableName(Callable callable) {
        if (callable == null) {
            return null;
        }

        String callableClassName = callable.getClass().getName();
        return (!callableClassName.contains(Callable.class.getSimpleName())) ?
                callableClassName : callable.toString();
    }

}

// A final note: in a typical industrial setting this class should be accompanied by unit tests, typically
// written before the class was coded at all. However this seemed a bit out of scope for this test so I
// omitted this step here.
